<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ArUco Original Minimal</title>
    <style>
        /* Reset y diseño base para pantalla completa móvil */
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; font-family: monospace; }

        /* Capa de interfaz superior (botón y logs) */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; z-index: 100;
            background: rgba(0, 0, 0, 0.5); padding: 10px; box-sizing: border-box;
            color: #0f0; pointer-events: none; /* Permitir clicks pasen abajo excepto en botones */
        }

        /* Botón visible e interactivo */
        #btnStart {
            pointer-events: auto; 
            display: block; width: 100%; padding: 15px; 
            background: #0066cc; color: white; border: none; font-size: 18px; border-radius: 8px;
            margin-bottom: 10px;
        }
        
        /* Área de registro de debug */
        #debug-log { max-height: 100px; overflow-y: auto; font-size: 12px; }

        /* Contenedor de video/canvas */
        #container { position: relative; width: 100%; height: 100%; }

        /* Video: Invisible pero activo para que el navegador lo renderice */
        #videoInput {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; opacity: 0.01; z-index: 1;
        }

        /* Canvas: Visible encima del video, donde dibujamos */
        #canvasOutput {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; z-index: 2;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <button id="btnStart" disabled>Cargando OpenCV...</button>
    <div id="debug-log">Estado inicial.</div>
</div>

<div id="container">
    <video id="videoInput" playsinline webkit-playsinline autoplay muted></video>
    <canvas id="canvasOutput"></canvas>
</div>

<script async src="https://docs.opencv.org/4.5.4/opencv.js" onload="onOpenCvReady()"></script>

<script>
    // --- UTILIDADES DE LOG ---
    const debugDiv = document.getElementById('debug-log');
    function log(msg) {
        console.log(msg);
        debugDiv.innerHTML = `> ${msg}<br>` + debugDiv.innerHTML;
    }

    // --- VARIABLES GLOBALES ---
    let video = document.getElementById('videoInput');
    let canvas = document.getElementById('canvasOutput');
    let btnStart = document.getElementById('btnStart');
    let stream = null;
    let streaming = false;
    
    // Variables de OpenCV (se inicializarán más tarde)
    let cap, src, gray, dictionary, markerIds, markerCorners, params;

    // 1. Se ejecuta cuando OpenCV descarga por completo
    function onOpenCvReady() {
        log("OpenCV.js cargado. Pulsa Iniciar.");
        btnStart.innerText = "INICIAR CÁMARA (ArUco Original)";
        btnStart.disabled = false;
        btnStart.onclick = startCameraFlow;
    }

    // 2. Flujo de inicio de cámara
    async function startCameraFlow() {
        btnStart.style.display = 'none'; // Ocultar botón
        log("Solicitando permisos de cámara...");

        try {
            // Pedir cámara trasera. Si falla, pedirá cualquiera.
            const constraints = { 
                video: { facingMode: { ideal: 'environment' } }, 
                audio: false 
            };
            
            stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;
            
            // Forzar reproducción explícita (necesario en algunos móviles)
            await video.play();
            log("Cámara activa. Esperando flujo de datos...");
            
            // INICIO DEL POLLING: Comprobar activamente si el video ya tiene dimensiones
            checkForVideoData();

        } catch (err) {
            log("ERROR CRÍTICO: " + err.name + " - " + err.message);
            log("Asegúrate de usar HTTPS.");
            btnStart.style.display = 'block'; btnStart.innerText = "Reintentar";
        }
    }

    // 3. Bucle de espera activa (Polling)
    function checkForVideoData() {
        if (video.videoWidth > 0 && video.videoHeight > 0) {
            // ¡Tenemos video!
            log(`Dimensiones recibidas: ${video.videoWidth}x${video.videoHeight}`);
            // Ajustar canvas al tamaño real del video
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            // Iniciar el procesamiento de OpenCV
            initOpenCVObjects();
        } else {
            log("Esperando dimensiones del video...");
            // Si aún es 0x0, volver a intentar en el siguiente frame
            requestAnimationFrame(checkForVideoData);
        }
    }

    // 4. Inicializar objetos de OpenCV (Solo una vez)
    function initOpenCVObjects() {
        streaming = true;
        log("Inicializando ArUco (Diccionario ORIGINAL)...");

        // Capturador de video
        cap = new cv.VideoCapture(video);
        // Matrices para almacenar imágenes
        src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
        gray = new cv.Mat();
        
        // CONFIGURACIÓN ARUCO: SOLO ORIGINAL
        dictionary = new cv.aruco_Dictionary(cv.DICT_ARUCO_ORIGINAL);
        params = new cv.aruco_DetectorParameters();
        
        // Variables para resultados
        markerIds = new cv.Mat();
        markerCorners = new cv.MatVector();

        log("Todo listo. Procesando frames.");
        requestAnimationFrame(processVideoLoop);
    }

    // 5. Bucle principal de procesamiento (se ejecuta en cada frame)
    function processVideoLoop() {
        if (!streaming) return;

        try {
            // Leer frame del video al Mat 'src'
            cap.read(src);
            
            // Convertir a escala de grises (necesario para detección)
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

            // DETECTAR MARCADORES
            cv.detectMarkers(gray, dictionary, markerCorners, markerIds, params);

            // Si se detecta algo, dibujar los resultados en 'src'
            if (markerIds.rows > 0) {
                // Color verde (RGBA: 0, 255, 0, 255)
                cv.drawDetectedMarkers(src, markerCorners, markerIds, new cv.Scalar(0, 255, 0, 255));
            }

            // Mostrar la imagen procesada ('src') en el canvas visible
            cv.imshow('canvasOutput', src);

        } catch (err) {
            console.error("Error en loop:", err);
            // No detenemos el bucle, solo logueamos el error
        }

        // Solicitar el siguiente frame
        requestAnimationFrame(processVideoLoop);
    }
</script>
</body>
</html>
