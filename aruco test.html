<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ArUco Círculos 25mm</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; font-family: sans-serif; overflow: hidden; }
        
        #container { position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; }
        #view-area { position: relative; flex: 1; overflow: hidden; background: #222; }

        video { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; opacity: 0.01; pointer-events: none;
        }
        canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: contain; z-index: 10;
        }

        /* BARRA SUPERIOR */
        #top-bar {
            background: rgba(0,0,0,0.8); color: white;
            padding: 10px; z-index: 20; border-bottom: 1px solid #444;
            display: flex; flex-direction: column; gap: 8px;
        }
        .row { display: flex; justify-content: space-between; align-items: center; }
        
        input[type=range] { flex: 1; margin: 0 10px; }
        .label-val { font-family: monospace; color: #0f0; min-width: 60px; text-align: right; }

        /* BOTONES INFERIORES */
        #controls {
            height: 80px; background: #111;
            display: flex; gap: 5px; padding: 5px; z-index: 20;
        }
        button {
            flex: 1; padding: 10px; font-size: 14px; font-weight: bold;
            color: white; border: none; border-radius: 4px; cursor: pointer;
        }
        #btnMode { background: #007bff; } 
        #btnClear { background: #dc3545; }
        
        /* POPUP DE RESULTADO */
        #measure-result {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8); color: #FFD700;
            padding: 8px 15px; border-radius: 20px; font-size: 18px; 
            font-weight: bold; z-index: 15; display: none; border: 2px solid #FFD700;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

<div id="container">
    <div id="top-bar">
        <div class="row">
            <span>Tamaño REAL Marcador:</span>
            <span id="lblSize" class="label-val">25mm</span>
        </div>
        <div class="row">
            <span>1mm</span>
            <input type="range" id="slideSize" min="10" max="100" step="1" value="25">
            <span>100mm</span>
        </div>
    </div>

    <div id="view-area">
        <div id="measure-result">0 mm</div>
        <video id="videoInput" playsinline webkit-playsinline autoplay muted></video>
        <canvas id="canvasOutput"></canvas>
    </div>

    <div id="controls">
        <button id="btnMode" disabled>Cargando Motor...</button>
        <button id="btnClear">Limpiar</button>
    </div>
</div>

<script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onCvLoaded()"></script>

<script>
    let video = document.getElementById('videoInput');
    let canvas = document.getElementById('canvasOutput');
    let btnMode = document.getElementById('btnMode');
    let btnClear = document.getElementById('btnClear');
    let slideSize = document.getElementById('slideSize');
    let lblSize = document.getElementById('lblSize');
    let resultBox = document.getElementById('measure-result');
    
    let stream = null;
    let streaming = false;
    let isMeasureMode = false; 
    let realMarkerSizeMM = 25; // Tamaño físico del marcador (Definido por usuario)
    const TARGET_CIRCLE_MM = 25; // Tamaño fijo del dibujo deseado
    
    // OpenCV objects
    let cap, src, rgb, gray, detector, markerIds, markerCorners;
    let selectedIds = new Set(); 

    function onCvLoaded() {
        btnMode.innerText = "Modo: SELECCIÓN";
        btnMode.disabled = false;
        startCamera();
        
        slideSize.oninput = (e) => {
            realMarkerSizeMM = parseInt(e.target.value);
            lblSize.innerText = realMarkerSizeMM + "mm";
        };

        btnMode.onclick = () => {
            isMeasureMode = !isMeasureMode;
            selectedIds.clear(); 
            resultBox.style.display = 'none';
            
            if (isMeasureMode) {
                btnMode.innerText = "Modo: REGLA (2 Puntos)";
                btnMode.style.background = "#FFD700"; 
                btnMode.style.color = "#000";
            } else {
                btnMode.innerText = "Modo: SELECCIÓN";
                btnMode.style.background = "#007bff"; 
                btnMode.style.color = "#FFF";
            }
        };

        btnClear.onclick = () => {
            selectedIds.clear();
            resultBox.style.display = 'none';
        };

        ['mousedown', 'touchstart'].forEach(evt => 
            canvas.addEventListener(evt, handleInput, {passive: false})
        );
    }

    function handleInput(e) {
        if (!markerCorners || markerIds.rows === 0) return;
        if (e.type === 'touchstart') e.preventDefault();

        const rect = canvas.getBoundingClientRect();
        const cx = e.clientX || e.touches[0].clientX;
        const cy = e.clientY || e.touches[0].clientY;

        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const clickPoint = new cv.Point((cx - rect.left) * scaleX, (cy - rect.top) * scaleY);

        let clickedId = -1;

        for (let i = 0; i < markerIds.rows; i++) {
            let id = markerIds.data32S[i];
            let corners = markerCorners.get(i);
            if (cv.pointPolygonTest(corners, clickPoint, false) >= 0) {
                clickedId = id;
                break;
            }
        }

        if (clickedId !== -1) {
            if (isMeasureMode) {
                if (selectedIds.has(clickedId)) {
                    selectedIds.delete(clickedId);
                } else {
                    if (selectedIds.size >= 2) selectedIds.clear();
                    selectedIds.add(clickedId);
                }
            } else {
                if (selectedIds.has(clickedId)) selectedIds.delete(clickedId);
                else selectedIds.add(clickedId);
            }
        }
    }

    async function startCamera() {
        try {
            stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment' }, audio: false 
            });
            video.srcObject = stream;
            await video.play();
            checkVideoReady();
        } catch (err) {
            console.error(err);
        }
    }

    function checkVideoReady() {
        if (video.videoWidth > 0) startProcessing();
        else requestAnimationFrame(checkVideoReady);
    }

    function startProcessing() {
        streaming = true;
        video.width = video.videoWidth; video.height = video.videoHeight;
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;

        cap = new cv.VideoCapture(video);
        src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
        rgb = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC3);
        gray = new cv.Mat();
        
        let dictionary = cv.getPredefinedDictionary(cv.DICT_ARUCO_ORIGINAL);
        let params = new cv.aruco_DetectorParameters();
        let refine = new cv.aruco_RefineParameters(10, 3, true);
        detector = new cv.aruco_ArucoDetector(dictionary, params, refine);
        
        markerIds = new cv.Mat();
        markerCorners = new cv.MatVector();

        requestAnimationFrame(processFrame);
    }

    function processFrame() {
        if (!streaming) return;

        try {
            if (video.videoWidth !== src.cols) {
                src.delete(); rgb.delete(); gray.delete();
                startProcessing(); return;
            }

            cap.read(src);
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            cv.cvtColor(src, rgb, cv.COLOR_RGBA2RGB);

            detector.detectMarkers(gray, markerCorners, markerIds);
            
            // Dibujar contornos verdes sutiles siempre para guiar
            if (markerIds.rows > 0) cv.drawDetectedMarkers(rgb, markerCorners, markerIds, new cv.Scalar(0, 255, 0));

            let selectedCenters = [];
            let pxPerMM_Factor = 0; // Para guardar la escala promedio

            for (let i = 0; i < markerIds.rows; i++) {
                let id = markerIds.data32S[i];

                if (selectedIds.has(id)) {
                    let c = markerCorners.get(i);
                    let arr = c.data32F;
                    
                    // 1. Calcular Centro
                    let centerX = (arr[0]+arr[2]+arr[4]+arr[6])/4;
                    let centerY = (arr[1]+arr[3]+arr[5]+arr[7])/4;
                    let centerPoint = new cv.Point(centerX, centerY);

                    // 2. Calcular Escala (Píxeles vs Realidad)
                    let perimeterPx = cv.arcLength(c, true);
                    let sidePx = perimeterPx / 4; 
                    
                    // Ratio: Cuántos píxeles es 1 mm en la realidad actual
                    let pxPerMM = sidePx / realMarkerSizeMM;
                    
                    // Guardamos para el cálculo de distancia luego
                    pxPerMM_Factor = pxPerMM; 

                    // 3. Calcular radio visual para 25mm
                    // Si quiero representar 25mm, multiplico 25 por mi factor de px/mm
                    // Dividimos por 2 porque drawCircle pide radio, no diámetro.
                    let radiusPx = (TARGET_CIRCLE_MM / 2) * pxPerMM;

                    // 4. Dibujar Círculo Sólido
                    let color = isMeasureMode ? new cv.Scalar(0, 215, 255) : new cv.Scalar(255, 0, 0); // Amarillo o Azul
                    
                    // -1 indica relleno
                    cv.circle(rgb, centerPoint, Math.round(radiusPx), color, -1);
                    
                    // Escribir ID (centrado)
                    cv.putText(rgb, ""+id, new cv.Point(centerX - 10, centerY + 5), 
                        cv.FONT_HERSHEY_SIMPLEX, 0.6, new cv.Scalar(255,255,255), 2);

                    selectedCenters.push({x: centerX, y: centerY});
                }
            }

            // --- MEDICIÓN DE DISTANCIA ---
            if (isMeasureMode && selectedCenters.length === 2) {
                let p1 = selectedCenters[0];
                let p2 = selectedCenters[1];

                let distPx = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                
                // Usamos el último factor calculado (asumimos que la cámara está paralela y el factor es similar)
                // Ojo: Si los marcadores están a distancias muy distintas, esto tiene margen de error.
                let distMM = distPx / pxPerMM_Factor;

                cv.line(rgb, new cv.Point(p1.x, p1.y), new cv.Point(p2.x, p2.y), new cv.Scalar(0, 0, 255), 3);
                
                resultBox.style.display = 'block';
                resultBox.innerText = `${distMM.toFixed(1)} mm`;
            } else {
                resultBox.style.display = 'none';
            }

            cv.imshow('canvasOutput', rgb);
            requestAnimationFrame(processFrame);

        } catch (err) {
            console.error(err);
        }
    }
</script>
</body>
</html>
