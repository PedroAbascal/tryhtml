<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ArUco Medición</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; font-family: sans-serif; overflow: hidden; }
        
        #container { position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; }
        #view-area { position: relative; flex: 1; overflow: hidden; background: #222; }

        video { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; opacity: 0.01; pointer-events: none;
        }
        canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: contain; z-index: 10;
        }

        /* PANEL DE CONTROL SUPERIOR */
        #top-bar {
            background: rgba(0,0,0,0.8); color: white;
            padding: 10px; z-index: 20; border-bottom: 1px solid #444;
            display: flex; flex-direction: column; gap: 8px;
        }
        .row { display: flex; justify-content: space-between; align-items: center; }
        
        /* Estilos del Slider */
        input[type=range] { flex: 1; margin: 0 10px; }
        .label-val { font-family: monospace; color: #0f0; min-width: 50px; text-align: right; }

        /* Botones inferiores */
        #controls {
            height: 80px; background: #111;
            display: flex; gap: 5px; padding: 5px; z-index: 20;
        }
        button {
            flex: 1; padding: 10px; font-size: 14px; font-weight: bold;
            color: white; border: none; border-radius: 4px; cursor: pointer;
        }
        #btnMode { background: #007bff; } /* Azul */
        #btnClear { background: #dc3545; } /* Rojo */
        
        /* Indicador de resultado flotante */
        #measure-result {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7); color: #FFD700;
            padding: 5px 10px; border-radius: 5px; font-size: 18px; 
            font-weight: bold; z-index: 15; display: none; border: 1px solid #FFD700;
        }
    </style>
</head>
<body>

<div id="container">
    <div id="top-bar">
        <div class="row">
            <span>Tamaño Marcador:</span>
            <span id="lblSize" class="label-val">25mm</span>
        </div>
        <div class="row">
            <span>1mm</span>
            <input type="range" id="slideSize" min="1" max="50" step="1" value="25">
            <span>50mm</span>
        </div>
    </div>

    <div id="view-area">
        <div id="measure-result">0 mm</div>
        <video id="videoInput" playsinline webkit-playsinline autoplay muted></video>
        <canvas id="canvasOutput"></canvas>
    </div>

    <div id="controls">
        <button id="btnMode" disabled>Cargando OpenCV...</button>
        <button id="btnClear">Limpiar / Reset</button>
    </div>
</div>

<script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onCvLoaded()"></script>

<script>
    let video = document.getElementById('videoInput');
    let canvas = document.getElementById('canvasOutput');
    let btnMode = document.getElementById('btnMode');
    let btnClear = document.getElementById('btnClear');
    let slideSize = document.getElementById('slideSize');
    let lblSize = document.getElementById('lblSize');
    let resultBox = document.getElementById('measure-result');
    
    // Variables de Estado
    let stream = null;
    let streaming = false;
    let isMeasureMode = false; // False = Selección Múltiple, True = Medir 2 Puntos
    let realMarkerSizeMM = 25; // Default 1 pulgada aprox
    
    // OpenCV objects
    let cap, src, rgb, gray, detector, markerIds, markerCorners;
    
    // Selección
    let selectedIds = new Set(); // Guardará los IDs seleccionados

    function onCvLoaded() {
        btnMode.innerText = "Modo: SELECCIÓN";
        btnMode.disabled = false;

        // INICIAR CÁMARA AUTOMÁTICAMENTE
        startCamera();
        
        // Listener Slider
        slideSize.oninput = (e) => {
            realMarkerSizeMM = parseInt(e.target.value);
            lblSize.innerText = realMarkerSizeMM + "mm";
        };

        // Listener Botón Modo
        btnMode.onclick = () => {
            isMeasureMode = !isMeasureMode;
            selectedIds.clear(); // Limpiar al cambiar de modo
            resultBox.style.display = 'none';
            
            if (isMeasureMode) {
                btnMode.innerText = "Modo: REGLA (2 Puntos)";
                btnMode.style.background = "#FFD700"; // Dorado
                btnMode.style.color = "#000";
            } else {
                btnMode.innerText = "Modo: SELECCIÓN";
                btnMode.style.background = "#007bff"; // Azul
                btnMode.style.color = "#FFF";
            }
        };

        // Listener Limpiar
        btnClear.onclick = () => {
            selectedIds.clear();
            resultBox.style.display = 'none';
        };

        // Eventos Touch/Click
        ['mousedown', 'touchstart'].forEach(evt => 
            canvas.addEventListener(evt, handleInput, {passive: false})
        );
    }

    function handleInput(e) {
        if (!markerCorners || markerIds.rows === 0) return;
        if (e.type === 'touchstart') e.preventDefault();

        const rect = canvas.getBoundingClientRect();
        const cx = e.clientX || e.touches[0].clientX;
        const cy = e.clientY || e.touches[0].clientY;

        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const clickPoint = new cv.Point((cx - rect.left) * scaleX, (cy - rect.top) * scaleY);

        let clickedId = -1;

        // Buscar qué marcador se tocó
        for (let i = 0; i < markerIds.rows; i++) {
            let id = markerIds.data32S[i];
            let corners = markerCorners.get(i);
            if (cv.pointPolygonTest(corners, clickPoint, false) >= 0) {
                clickedId = id;
                break;
            }
        }

        if (clickedId !== -1) {
            if (isMeasureMode) {
                // LÓGICA MODO REGLA (Solo permite 2)
                if (selectedIds.has(clickedId)) {
                    selectedIds.delete(clickedId); // Deseleccionar
                } else {
                    if (selectedIds.size >= 2) {
                        // Si ya hay 2, borramos todo y seleccionamos el nuevo
                        selectedIds.clear();
                    }
                    selectedIds.add(clickedId);
                }
            } else {
                // LÓGICA MODO SELECCIÓN (Infinitos)
                if (selectedIds.has(clickedId)) selectedIds.delete(clickedId);
                else selectedIds.add(clickedId);
            }
        }
    }

    async function startCamera() {
        try {
            stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment' }, 
                audio: false 
            });
            video.srcObject = stream;
            await video.play();
            checkVideoReady();
        } catch (err) {
            console.error(err);
            alert("Error: " + err.message);
        }
    }

    function checkVideoReady() {
        if (video.videoWidth > 0) startProcessing();
        else requestAnimationFrame(checkVideoReady);
    }

    function startProcessing() {
        streaming = true;
        video.width = video.videoWidth; video.height = video.videoHeight;
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;

        cap = new cv.VideoCapture(video);
        src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
        rgb = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC3);
        gray = new cv.Mat();
        
        let dictionary = cv.getPredefinedDictionary(cv.DICT_ARUCO_ORIGINAL);
        let params = new cv.aruco_DetectorParameters();
        let refine = new cv.aruco_RefineParameters(10, 3, true);
        detector = new cv.aruco_ArucoDetector(dictionary, params, refine);
        
        markerIds = new cv.Mat();
        markerCorners = new cv.MatVector();

        requestAnimationFrame(processFrame);
    }

    function processFrame() {
        if (!streaming) return;

        try {
            if (video.videoWidth !== src.cols) {
                src.delete(); rgb.delete(); gray.delete();
                startProcessing(); return;
            }

            cap.read(src);
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            cv.cvtColor(src, rgb, cv.COLOR_RGBA2RGB);

            detector.detectMarkers(gray, markerCorners, markerIds);
            
            // Dibujar base verde
            if (markerIds.rows > 0) cv.drawDetectedMarkers(rgb, markerCorners, markerIds, new cv.Scalar(0, 255, 0));

            // Arrays para guardar datos de los marcadores seleccionados para calcular distancia luego
            let selectedCenters = [];
            let selectedPerimeters = [];

            // Bucle de dibujado y recolección de datos
            for (let i = 0; i < markerIds.rows; i++) {
                let id = markerIds.data32S[i];

                if (selectedIds.has(id)) {
                    let c = markerCorners.get(i); // Corners Mat
                    let arr = c.data32F; // [x1,y1, x2,y2, ...]
                    
                    // 1. Dibujar Resaltado (Azul o Dorado según modo)
                    let color = isMeasureMode ? new cv.Scalar(0, 215, 255) : new cv.Scalar(255, 0, 0); // Dorado vs Azul
                    let polyPoints = cv.matFromArray(4, 1, cv.CV_32SC2, [
                        arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7]
                    ]);
                    cv.fillConvexPoly(rgb, polyPoints, color);
                    polyPoints.delete();

                    // 2. Calcular Centro
                    let centerX = (arr[0]+arr[2]+arr[4]+arr[6])/4;
                    let centerY = (arr[1]+arr[3]+arr[5]+arr[7])/4;
                    selectedCenters.push({x: centerX, y: centerY});

                    // 3. Calcular Perímetro (para estimar escala)
                    // cv.arcLength(curve, closed)
                    let perim = cv.arcLength(c, true);
                    selectedPerimeters.push(perim);
                }
            }

            // --- LÓGICA DE MEDICIÓN ---
            if (isMeasureMode && selectedCenters.length === 2) {
                let p1 = selectedCenters[0];
                let p2 = selectedCenters[1];

                // 1. Distancia en PIXELES
                let distPx = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));

                // 2. Calcular factor de escala (Píxeles por MM)
                // Usamos el promedio del tamaño aparente de ambos marcadores para reducir error de perspectiva
                let avgPerim = (selectedPerimeters[0] + selectedPerimeters[1]) / 2;
                let avgSidePx = avgPerim / 4; // Lado promedio en píxeles
                
                // Regla de tres: avgSidePx equivale a realMarkerSizeMM
                let pixelsPerMM = avgSidePx / realMarkerSizeMM;

                // 3. Distancia REAL
                let distMM = distPx / pixelsPerMM;

                // 4. Dibujar línea y texto
                cv.line(rgb, new cv.Point(p1.x, p1.y), new cv.Point(p2.x, p2.y), new cv.Scalar(0, 0, 255), 3);
                
                // Actualizar interfaz HTML
                resultBox.style.display = 'block';
                resultBox.innerText = `Distancia: ${distMM.toFixed(1)} mm`;

            } else {
                resultBox.style.display = 'none';
            }

            cv.imshow('canvasOutput', rgb);
            requestAnimationFrame(processFrame);

        } catch (err) {
            console.error(err);
        }
    }
</script>
</body>
</html>z
