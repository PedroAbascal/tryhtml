<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ArUco Force Test</title>
    <style>
        body { margin: 0; background: #000; color: #0f0; font-family: monospace; display: flex; flex-direction: column; align-items: center; height: 100vh; overflow: hidden; }
        
        #controls { 
            position: absolute; top: 0; left: 0; width: 100%; 
            background: rgba(0,0,0,0.8); z-index: 50; padding: 10px; box-sizing: border-box; text-align: center; 
        }
        
        button { font-size: 1.2rem; padding: 15px 30px; background: #007bff; color: white; border: none; border-radius: 5px; margin-bottom: 5px; }
        select { font-size: 1rem; padding: 8px; margin-bottom: 5px; }
        
        #log { 
            font-size: 0.75rem; color: #ff0; 
            max-height: 80px; overflow-y: auto; 
            text-align: left; background: #111; padding: 5px; border: 1px solid #444; 
        }

        #container { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }

        /* EL TRUCO: Video de 1px visible para forzar renderizado, pero no molesta */
        video { 
            position: absolute; top: 0; left: 0; 
            width: 1px; height: 1px; opacity: 0.01; 
            pointer-events: none;
        }

        canvas { 
            width: 100%; height: 100%; 
            object-fit: contain; 
        }
    </style>
</head>
<body>

<div id="controls">
    <button id="btnStart" onclick="startSystem()">INICIAR SYSTEM</button>
    <br>
    <select id="dictSelect" onchange="updateDictionary()">
        <option value="4x4">4x4 (Estándar)</option>
        <option value="5x5">5x5</option>
        <option value="ORIGINAL">Original</option>
    </select>
    <div id="log">Sistema listo.</div>
</div>

<div id="container">
    <video id="videoInput" playsinline webkit-playsinline autoplay muted></video>
    <canvas id="canvasOutput"></canvas>
</div>

<script async src="https://docs.opencv.org/4.5.4/opencv.js" onload="onCvLoaded()"></script>

<script>
    const logDiv = document.getElementById('log');
    function log(msg) { logDiv.innerHTML = `> ${msg}<br>` + logDiv.innerHTML; console.log(msg); }

    let video = document.getElementById('videoInput');
    let canvas = document.getElementById('canvasOutput');
    let btnStart = document.getElementById('btnStart');
    let select = document.getElementById('dictSelect');

    let stream = null;
    let streaming = false;
    let cvLoaded = false;
    
    // Variables OpenCV
    let cap, src, gray, dictionary, markerIds, markerCorners, params;
    let dictMap = {};

    function onCvLoaded() {
        cvLoaded = true;
        log("OpenCV Cargado correctamente.");
        dictMap = {
            "4x4": cv.DICT_4X4_250,
            "5x5": cv.DICT_5X5_250,
            "ORIGINAL": cv.DICT_ARUCO_ORIGINAL
        };
    }

    async function startSystem() {
        if (!cvLoaded) return log("Espera a que cargue OpenCV...");
        
        btnStart.style.display = 'none';
        log("Solicitando cámara...");

        try {
            // Intentamos obtener cámara trasera con configuración simple
            const constraints = { 
                video: { facingMode: 'environment' }, 
                audio: false 
            };
            
            stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;
            
            log("Stream asignado. Forzando play()...");
            
            // Promesa explicita de play
            await video.play();
            
            log("Video reproduciendo. Esperando dimensiones...");
            
            // AQUÍ ESTÁ EL CAMBIO: Polling en lugar de evento
            checkVideoDimensions();

        } catch (err) {
            log("ERROR: " + err.message);
            btnStart.style.display = 'inline-block';
            btnStart.innerText = "Reintentar";
        }
    }

    // Función recursiva que comprueba si el video ya tiene tamaño
    function checkVideoDimensions() {
        if (video.videoWidth > 0 && video.videoHeight > 0) {
            log(`Dimensiones detectadas: ${video.videoWidth}x${video.videoHeight}`);
            
            // Configurar canvas al tamaño real
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            startOpenCV();
        } else {
            // Si aún es 0, volver a comprobar en el siguiente frame
            requestAnimationFrame(checkVideoDimensions);
        }
    }

    function startOpenCV() {
        if (streaming) return;
        streaming = true;
        log("Iniciando procesamiento OpenCV...");

        cap = new cv.VideoCapture(video);
        src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
        gray = new cv.Mat();
        
        updateDictionary();
        
        params = new cv.aruco_DetectorParameters();
        // Ajustes para mejorar detección en móviles (opcional)
        // params.adaptiveThreshWinSizeMin = 3;
        // params.adaptiveThreshWinSizeMax = 23;
        
        markerIds = new cv.Mat();
        markerCorners = new cv.MatVector();

        requestAnimationFrame(processFrame);
    }

    function updateDictionary() {
        if (!cvLoaded) return;
        if (dictionary) dictionary.delete();
        dictionary = new cv.aruco_Dictionary(dictMap[select.value]);
        log("Diccionario cambiado a: " + select.value);
    }

    function processFrame() {
        try {
            if (!streaming) return;

            // Leer frame
            cap.read(src);
            
            // Convertir a gris
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

            // Detectar
            cv.detectMarkers(gray, dictionary, markerCorners, markerIds, params);

            // Dibujar marcadores
            if (markerIds.rows > 0) {
                cv.drawDetectedMarkers(src, markerCorners, markerIds, new cv.Scalar(0, 255, 0, 255));
                // Opcional: Mostrar IDs en consola si se desea depurar
                // log("Detectado ID: " + markerIds.data32S[0]); 
            }

            // Mostrar resultado final
            cv.imshow('canvasOutput', src);

            requestAnimationFrame(processFrame);
        } catch (err) {
            // Si da error, reintentamos sin bloquear
            console.error(err);
            requestAnimationFrame(processFrame);
        }
    }
</script>
</body>
</html>
